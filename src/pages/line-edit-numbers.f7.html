<template>
    <div class="page">
        <div class="navbar">
            <div class="navbar-bg"></div>
            <div class="navbar-inner sliding">
                <div class="left">
                    <a {{#if loading}}href=""{{else}}href="/song/view/{{this.songId}}/"{{/if}} class="link back" data-force="true" data-ignore-cache="true">
                        <i class="icon icon-back"></i> 
                        <span class="if-not-md" >{{#if loading}}Back{{else}}{{translate "Back"}}{{/if}}</span>
                    </a>
                </div>
                <div class="title">{{#if loading}}{{else}} {{song.title[defaultLanguage]}} : {{@root.verseLabel}} {{/if}}</div>
            </div>
        </div>
        <div class="page-content hide-navbar-on-scroll">
            {{#js_if "!@root.loading"}}
                <div class="block block-strong" style="margin-bottom: 10px; overflow: hidden;">
                    <div class="menu">
                        <div class="menu-inner no-margin-padding">
                            <!-- Stepper element -->
                            <div class="stepper stepper-large stepper-fill" style="display: none; margin-left: auto; height: 40px;">
                                <div class="stepper-button-minus"></div>
                                <div class="stepper-input-wrap">
                                    <input type="text" value="{{transpose song.key @root.steps}}" readonly>
                                </div>
                                <div class="stepper-button-plus"></div>
                            </div>
                            <div>
                                <div class="menu-item">
                                    <div class="menu-item-content icon-only">
                                        <div class="menu-item-content">
                                            <a @click="save" class="col button button-fill">
                                                <i class="text-color-gray fa-bigger fas fa-save"></i>
                                            </a>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="menu-item">
                                <div class="menu-item-content icon-only">
                                    <div class="menu-item-content">
                                        <a class="col button button-fill{{#if firstLine}} disabled{{/if}}" @click="prevLine">
                                            <i class="text-color-gray fas fa-bigger fa-arrow-left"></i>
                                        </a>
                                    </div>
                                </div>
                            </div>
                            <!--
                            goto next
                            -->
                            <div class="menu-item">
                                <div class="menu-item-content icon-only">
                                    <div class="menu-item-content">
                                        <a @click="nextLine" class="col button button-fill{{#js_if "@root.lastLine && @root.lastVerse"}} disabled{{/js_if}}">
                                            <i class="text-color-gray fa-bigger fas fa-arrow-right"></i>
                                        </a>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="item-title item-label">
                                Number tools:
                            </div>
                            <!--
                                phrase
                            -->
                            <div class="menu-item">
                                <div class="menu-item-content icon-only">
                                    <div class="menu-item-content">
                                        <a @click="addNote" class="col button">
                                            <i class="text-color-gray fas fa-plus"></i>
                                        </a>
                                    </div>
                                </div>
                            </div>
                            <!--
                                delete phrase, only show if totally empty??????
                            -->
                            <div class="menu-item">
                                <div class="menu-item-content icon-only">
                                    <div class="menu-item-content">
                                        <a @click="deleteNote" class="col button">
                                            <i class="text-color-gray fas fa-trash"></i>
                                        </a>
                                    </div>
                                </div>
                            </div>
                            <!--
                            LINE
                            -->
                            <!-- <div class="item-title item-label">
                                <t>Line tools:</t>
                            </div>
                            <div class="menu-item">
                                <div class="menu-item-content icon-only">
                                    <div class="menu-item-content">
                                        <a @click="addLine" class="col button button-fill">
                                            <i class="text-color-gray fa-bigger fas fa-plus"></i>
                                        </a>
                                    </div>
                                </div>
                            </div>
                            <div class="menu-item">
                                <div class="menu-item-content icon-only">
                                    <div class="menu-item-content">
                                        <a class="col button button-fill" @click="deleteLine">
                                            <i class="text-color-gray fa-bigger fas fa-trash"></i>
                                        </a>
                                    </div>
                                </div>
                            </div> -->
                        </div>
                    </div>

                    <div class="sheet">
                        <div class="song">
                            <div class="verse">
                                <div class="line" id="edit-line">
                                    <!-- -->
                                    {{ printEachNumber @root.line.numbers }}
                                    <!-- -->
                                    {{ printLyric @root.line}}
                                </div>
                            </div>
                        </div>
                    </div>
                {{#js_if "@root.savable"}}
                    <p><a @click="save"  class="col popup-close button button-fill">*Save</a></p>
                {{/js_if}}
                </div>
                <div class="block text-align-right text-color-gray" style="margin-top: 10px;">
                    {{song.author[defaultLanguage]}}
                </div>
            {{/js_if}}
        </div>
    </div>
</template>
<style>
    .noUi-marker {
        height: 0 !important;
    }

    .no-margin-padding {
        margin: 0;
        padding: 0;
    }

    .fa-bigger {
        font-size: larger;
    }

    .song {
        transform-origin: left top;
    }

    .line {
        margin-bottom: 20px;
    }

    .phrase {
        position: relative;
        display: inline-block;
        margin: 55px 10px 0 0;
        min-width: 20px;
    }

    .chord,
    .number {
        top: -55px;
        background: var(--f7-theme-color);
        border-radius: 3px;
        min-width: 20px;
        height: 20px;
        line-height: 20px;
        text-align: center;
        color: white;
        font-weight: bold;
        display: inline-block;
        padding: 0 2px;
        margin-right: 5px;
        position: absolute;
        padding: 2px;
    }

    .number {
        top: -25px;
        border-radius: 100%;
        width: 20px;
        height: 20px;
        padding: 2px;
        background: var(--f7-color-blue);
        font-family: 'Notes', monospace;
    }

    .noNumbers,
    .noChords {
        margin-top: 30px !important;
    }

    .noNumbers.noChords {
        margin-top: 10px !important;
    }

    .noNumbers .chord,
    .noChords .chord {
        top: -30px;
    }
    .item-input-wrap{
        width: 100%;
    }
</style>
<script>
    var app
    var firstLine
    var languages
    var lastLine
    var lastVerse
    var line
    var lineId
    var loading
    var lyricList
    var numberArray = [];
    var numberStartLocations
    var savable = false;
    var song
    var songId
    var verseId
    var verseLabel
    import 'nouislider/dist/nouislider.css';
    import DataManager from '../data/dataManager';
    import LineModulate from '../data/lineModulate';
    import noUiSlider from 'nouislider';
    import ParseText from "../data/parseText";
    import Preference from "../data/preference";
    import Song from '../data/song';
        
    const dataManager = new DataManager();
    const lineModulate = new LineModulate();
    const parseText = new ParseText();
    const preference = new Preference();
    const songCollection = new Song();
    
    // Import locales
    const locale = require('../js/locales.js');

    var initScale = 1;
    var lyric1;
    var lyric2;
    var defaultLanguage;
    var deviceWidth = window.innerWidth;
    var self = this;
    if (deviceWidth >= 700) {
        initScale = 2;
    } else if (deviceWidth >= 500) {
        initScale = 1.5;
    }
    var steps = 0;

    export default {
        // Component Data
        data: function() {
            // Must return an object
            self = this;
            return {
                loading: true,
                savable: savable,
                lastVerse: false,
                lastLine: false,
                firstLine: false,
                showNumber: false,
                showChord: false
            }
        },
        // Page Events
        on: {
            pageInit: function(e, page) {
                self = this;
                app = self.$app;
                var $form = this.$('#edit-line')
                
                songId = this.$route.params.songId;
                verseId = this.$route.params.verseId;
                lineId = this.$route.params.lineId;
                
                // get global savable
                self.savableUpdate(app.savable);

                preference.getLanguage().then((languageCode) => {
                    lyric1 = languageCode;
                    defaultLanguage = languageCode;
                    languages = [];
                    lyricList = []
                    var result = app.song;
                    var translationLangs = Object.keys(result.lyrics.verses[verseId].lines[lineId].phrases[0]);
                    //var translationLangs = Object.keys(result.title);
                    locale.customLocales.forEach((item) => {
                        if (translationLangs.indexOf(item.tag) > -1) {
                            if (item.tag == lyric1) {
                                item.default = true;
                            }
                            languages.push(item.tag)
                        }
                    });
                    line = result.lyrics.verses[verseId].lines[lineId]

                    // check if last line
                    lastLine = (lineId >= (result.lyrics.verses[verseId].lines.length - 1));
                    lastVerse = (verseId >= (result.lyrics.verses.length - 1));
                    // song is used to get next line
                    song = result

                    self.$setState({
                        loading: false,
                        savable: savable,
                        songId: songId,
                        lastLine: lastLine,
                        lastVerse: lastVerse,
                        verseLabel: result.lyrics.verses[verseId].label,
                        firstLine: (lineId == 0 && verseId == 0),
                        song: song,
                        // verse: result.verse[verseId],
                        line: line,
                        steps: steps,
                        languages: languages,
                        lyricList: lyricList,
                        defaultLanguage: defaultLanguage
                    }, () => {
                        self.$(".song")[0].style.transform = "scale(" + initScale + ")";
                        self.$(".sheet")[0].style.height = (self.$(".song")[0].offsetHeight * initScale) + "px";

                        // make the sliders
                        self.displayLyricSliders()

                        languages.forEach(lang => {
                            line.phrases.forEach(phrase => {
                                lyricList.push({
                                    "tag": lang,
                                    "lyric": line[lang]
                                })
                            });
                        });

                        var stepper = app.stepper.create({
                            el: '.stepper',
                            value: steps,
                            min: 0,
                            max: 11,
                            wraps: true,
                            on: {
                                change: function(e) {
                                    steps = e.value;
                                    self.$setState({
                                        steps: steps,
                                    });
                                }
                            }
                        });
                    });
                });
            },
        },
        methods: {
            zoomIn: function(e) {
                initScale += 0.05;
                this.$(".song")[0].style.transform = "scale(" + initScale + ")";
                this.$(".sheet")[0].style.height = (this.$(".song")[0].offsetHeight * initScale) + "px";
            },
            zoomOut: function(e) {
                initScale -= 0.05;
                this.$(".song")[0].style.transform = "scale(" + initScale + ")";
                this.$(".sheet")[0].style.height = (this.$(".song")[0].offsetHeight * initScale) + "px";
            },
            save: function(e) {
                var $form = this.$('#edit-line')
                var $ = $form.find("select[name='']") //relation
                if (!self.$app.input.validateInputs('#edit-line')) {
                    // TODO make this say what the error is
                    self.$app.dialog.alert('Please correct your entries.');
                    console.error('<t>Please correct your entries.</t>');
                } else {
                    let newData = song; 
                    var metaIndex = 0 
                    numberArray = []
                    while ( metaIndex < newData.lyrics.verses[verseId].lines[lineId].numbers.length ){
                        let id = ('.number').concat(metaIndex)
                        let number = self.$(id)[0]//.value // self.$('.number1').firstElementChild.value
                        if (number) { // our template will not create form if it's supposed to be blank
                            // setting number
                            let number = self.$(id)[0].value 
                            numberArray.push(number)
                        } 
                        metaIndex++;
                    }
                    
                    var newPhrasesCombined = [];
                    languages.forEach(langTag => { // selected language
                        newPhrasesCombined = lineModulate.combineLines(newPhrasesCombined, self.parseLanguageText(langTag));
                    });  

                    newData.lyrics.verses[verseId].lines[lineId].phrases = newPhrasesCombined;
                    newData.lyrics.verses[verseId].lines[lineId].numbers = numberArray;
                    // // this only updates the numbers, **if the nouisliders were not modified** this would be a fast way of updating just the notes
                    // var metaIndex = 0;
                    // var phraseIndex = 0;

                    // while (phraseIndex < newData.lyrics.verses[verseId].lines[lineId].phrases.length) {
                    //     if(newData.lyrics.verses[verseId].lines[lineId].phrases[phraseIndex].number){
                    //         let id = ('.number').concat(metaIndex)
                    //         let number = self.$(id)[0]//.value // self.$('.number1').firstElementChild.value
                    //         if (number) { // our template will not create form if it's supposed to be blank
                    //             // setting number
                    //             let number = self.$(id)[0].value 
                    //             newData.lyrics.verses[verseId].lines[lineId].phrases[phraseIndex]['number'] = number
                    //         }
                    //         metaIndex ++;
                    //     }
                    //     phraseIndex++;
                    // };
                    
                    // save
                    line = {
                        'phrases':newPhrasesCombined,
                        'numbers':numberArray
                    };
                    song = newData;
                    app.song = newData;
                    //songCollection.db.setItem(songId, newData);
                    self.savableUpdate(false);
                    //self.clearSliders();

                    // TODO  when there are 3+ languages sliders get nuked somewhere starting here
                    self.$setState({
                        loading: false,
                        song: newData,
                        line: newData.lyrics.verses[verseId].lines[lineId]
                    }, () => {
                        // <endTODO>The slider elements are destroyed by now
                        self.displayLyricSliders();
                    });
                    // send line changes to server
                    // dataManager.putLine(songId, verseId, lineId, newData.lyrics.verses[verseId].lines[lineId])
                    //     .then(responseText => alert(JSON.stringify(responseText)));
                    // send whole song to server
                    // dataManager.putSong(songId, newData)
                    //  .then(responseText => alert(JSON.stringify(responseText)));
                
                }
            },
            // make phraseList 
            parseLanguageText: function(tag, languageArr, insertArray, chordMap){
                // I need the full string "Twinkle, twinkle, little star"
                // I need placment of phrase breaks ["0.00", "10.00", "15.00"]
                // make phrases list:
                var phraseArray = [] ;
                // [(en:'Twinkl%e, tw'),(chord:'A',en:'ink%le'),(chord:'E',en:', litt%le star%%%'),(chord:'D',en:'%%%')] 
                if(!insertArray){ // get from dom
                    try {
                        insertArray = this.$$(`#slider-${tag}`)[0].noUiSlider.get()
                    } catch (error) {
                        console.error(error)
                    }
                    if (!insertArray) {
                        console.error({"no div for tag":tag})
                    }
                }
                
                if(!languageArr){ // get from global var
                    try {
                        languageArr = []
                        chordMap = []
                        var languageLen = 0
                        var lastLength = 0
                        var first = true;
                        line.phrases.forEach(phrase => {
                            if (Object.hasOwnProperty.call(phrase, tag)) {
                                // let cleanLyric = lineModulate.hiddenStringCleaner(phrase[tag]); // this doesn't work?
                                let cleaner = phrase[tag].replaceAll(String.fromCharCode(173), '')
                                let arr = lineModulate.diacriticCheckerChord(cleaner, 0);
                                languageArr = languageArr.concat(arr)
                                languageLen += arr.length
                            } 
                            let phraseMap = {}
                            if (Object.hasOwnProperty.call(phrase, 'chord')) { // has chord
                                phraseMap['len'] = lastLength // we get distance from start
                                lastLength = languageLen
                                phraseMap['chord'] = phrase['chord']
                                chordMap.push(phraseMap)
                            } else if ( !Object.hasOwnProperty.call(phrase, 'chord') && first ) { 
                                // first phrase is chordless,
                                phraseMap['len'] = 0 // is start
                                lastLength =  languageLen
                                phraseMap['chord'] = ''
                                chordMap.push(phraseMap)
                            }

                            first = false;
                        });
                    } catch (error) {
                        console.error(error)
                    }
                    if (!languageArr) {
                        console.error({"no line data for tag":tag});
                    }
                }
                // // tool: if there are to many number markers run this
                // for (let index = 0; index < languageArr.length; index++) {
                //     if (languageArr[index].includes(String.fromCharCode(173))){
                //         console.error("found hidden char, should all be stripped")
                //     }
                // }

                if (typeof insertArray === 'string'){// there's only the one number 
                    let numberLoc = parseInt(insertArray)
                    languageArr[numberLoc] = String.fromCharCode(173).concat(languageArr[numberLoc]) 
                } else {
                    // array of strings to array of useable indexes
                    var numberMap = [];
                    insertArray.forEach(element => {
                        numberMap.push( parseInt(element) );
                    });

                    var firstChord = true;

                    var i = 0;
                    console.log(chordMap) // this is the expected map
                    console.log(languageArr) // lyrics with number markers NOT messing in indexes

                    // from JSON
                    // chordMap
                    // from nouislider
                    // insertArray
                    //if(tag == 'en'){debugger}
                    numberMap.forEach((element) => {
                        if ( element < languageArr.length ){
                            languageArr[element] = String.fromCharCode(173).concat(languageArr[element]) ; // 
                            //languageArr[element] = "%".concat(languageArr[element]) ; 
                        } else { //put it into last
                            //languageArr.push("%".concat(String.fromCharCode(173)))
                            languageArr.push(String.fromCharCode(173))
                        }
                    });
                }
                if (chordMap){
                    var first = true;
                    var chordMapi = 0;
                    while(chordMap[chordMapi]){ 
                        let currentChord = chordMap[chordMapi];
                        let phraseLen = ( chordMap[chordMapi+1]? (chordMap[chordMapi+1].len-currentChord.len) : languageArr.length ); // sub next len from curr lent to get expected strong. if no next get whole string
                        let e = {}

                        if( first ){
                            // phrase 0 can lack a chord/num, if it does, we show it via ''
                            if ( currentChord['chord'] != '' ){
                                e.chord = currentChord.chord;
                            }
                            if ( phraseLen > 0) {
                                e[tag] = languageArr.splice(0,phraseLen).join('')
                            } 
                            first = false;
                        } else { 
                            e.chord = currentChord.chord
                            e[tag] = languageArr.splice(0,phraseLen).join('')
                        }
                        chordMapi++
                        phraseArray.push(e)
                    }
                } else { 
                    // no chords, possibly no numbers.
                    phraseArray.push(e[tag] = languageArr.join(''))
                }
                // if(tag == 'en'){
                //     console.log({'new line': phraseArray, 'old line':line.phrases});
                //    // debugger
                // }
                return phraseArray;
            },
            nextLine: function(e) {
                // only get index forward if it exists in song
                if (lastLine && !lastVerse) { // if at end of NOTlastVerse, check next verse
                    lastVerse = ((verseId + 1) >= (song.lyrics.verses.length - 1)); // is next verse last verse?
                    lastLine = ((song.lyrics.verses[parseInt(verseId) + 1].lines[1]) == undefined); // is there only one line in next verse?
                    ++verseId;
                    lineId = 0;
                    verseLabel = song.lyrics.verses[verseId].label;
                } else {
                    // check if last line
                    lastLine = ((lineId + 1) >= (song.lyrics.verses[verseId].lines.length - 1));
                    ++lineId;
                }
                // update variable
                line = song.lyrics.verses[verseId].lines[lineId]
                self.clearSliders()
                self.$setState({
                    loading: false,
                    firstLine: (lineId == 0 && verseId == 0),
                    lastLine: lastLine,
                    lastVerse: lastVerse,
                    verseLabel: verseLabel,
                    line: song.lyrics.verses[verseId].lines[lineId]
                }, () => {
                    self.clearSliders()
                    self.displayLyricSliders()
                });
            },
            prevLine: function(e) {
                if (lineId == 0) {
                    --verseId
                    lineId = song.lyrics.verses[verseId].lines.length - 1
                    // update variable
                    lastVerse = ((verseId) >= (song.lyrics.verses.length - 1)); // is next verse last verse?
                    verseLabel = song.lyrics.verses[verseId].label;
                } else {
                    --lineId
                }
                line = song.lyrics.verses[verseId].lines[lineId]
                self.clearSliders()
                self.$setState({
                    loading: false,
                    firstLine: (lineId == 0 && verseId == 0),
                    lastLine: false,
                    verseLabel: verseLabel,
                    lastVerse: lastVerse,
                    line: song.lyrics.verses[verseId].lines[lineId]
                }, () => {
                    self.displayLyricSliders()
                });
            },
            addNote: function(e) {
                let newData = song
                // At index, add one element

                var phraseArray = newData.lyrics.verses[verseId].lines[lineId].phrases
                var workingIndex = phraseArray.length - 1; // get last index

                for (const tag in phraseArray[workingIndex]) {
                    if (Object.hasOwnProperty.call(phraseArray[workingIndex], tag) && tag != 'chord') {
                        phraseArray[workingIndex][tag] = (phraseArray[workingIndex][tag]).concat(String.fromCharCode(173))
                    }
                }
                

                newData.lyrics.verses[verseId].lines[lineId].phrases = phraseArray
                newData.lyrics.verses[verseId].lines[lineId].numbers.push('1');
                app.song = newData;
                self.savableUpdate(true);
                song = newData;
                line = song.lyrics.verses[verseId].lines[lineId];
                self.clearSliders()
                self.$setState({
                    loading: false,
                    song: newData,
                    line: newData.lyrics.verses[verseId].lines[lineId]
                }, () => {
                    self.displayLyricSliders()
                });
            },
            savableUpdate: function(bool) {
                if (typeof(bool) != 'boolean'){
                    bool = false;
                }
                app.savable = bool;
                savable = bool;
                self.$setState({
                    savable: bool
                });
            },
            deleteNote: function(e) {
                if( line.numbers.length <= 1 ){
                    return;
                }
                let newData = song;

                newData.lyrics.verses[verseId].lines[lineId].numbers.pop(); // get the number out

                var workingIndex = (newData.lyrics.verses[verseId].lines[lineId].phrases).length - 1;
                languages.forEach(langTag => {
                    // tick through each language tag, search from end of line, remove last occurence of hidden character. 
                    newData.lyrics.verses[verseId].lines[lineId] = deleteTheCharacter(newData.lyrics.verses[verseId].lines[lineId],workingIndex,langTag);
                });

                function deleteTheCharacter(line,index,langTag){
                    if(index<0){console.error("trying to delete a character that doesn't exist"); return;}
                    let hiddenCharLocation = line.phrases[index][langTag].lastIndexOf(String.fromCharCode(173));
                    if ( hiddenCharLocation === -1 ){ // not here, recurse
                        deleteTheCharacter(line,++index,langTag)
                    } else { // remove and return line sans one hidden character
                        // regx option, not sure how to use the hidden char here
                        // var str = 'a_b_c';
                        // console.log(  str.replace(/_([^_]*)$/, '$1')  ) //a_bc
                        let str = line.phrases[index][langTag].split('')
                        str.splice(hiddenCharLocation, 1)
                        line.phrases[index][langTag] = str.join('')
                        return line
                    }
                }

                line = newData.lyrics.verses[verseId].lines[lineId]
                app.song = newData;
                self.savableUpdate(true)
                self.clearSliders()
                self.$setState({
                    loading: false,
                    song: newData,
                    line: newData.lyrics.verses[verseId].lines[lineId]
                }, () => {
                    self.displayLyricSliders()
                });
            },
            clearSliders: function() {
                languages.forEach(languageCode => {
                    var slider = self.$(`.slider-${languageCode}`)[0];
                    if (slider) {
                        if (slider.noUiSlider) {
                            slider.noUiSlider.destroy();
                        }
                    }
                });
            },
            displayLyricSliders: function(e) {
                // 
                var lyric = {};
                numberStartLocations = {}; //  {'en':[1,5,12]}
                //var noteList = [];           // tooltips: [ {to: function() {return "2<br/>A";} } ]
                var noteList = [];  
                line.numbers.forEach(element => {
                    noteList.push({
                        'to': function() {
                            return `${element}`
                        }
                    })
                });

                // init each language
                languages.forEach(languageCode => {
                    numberStartLocations[languageCode] = [];
                    lyric[languageCode] = [];
                });

                var firstPhrase = true;
                var lineModulated = lineModulate.consolidate(line)
                //
                for (const key in lineModulated) {
                    if (Object.hasOwnProperty.call(lineModulated, key)) {
                        // we're working with a single language here
                        // combining the whole line together (as if there were no chords)
                        // then splitting it back out as if the numbers were chords
                        const lang = lineModulated[key];
                        const element = lineModulated[key];
                        const languageLineCombinedLyric = lang.lyric;
                        const languageLineCombinedChordLocations = lang.chords;

                        // we need to split each of these in relation to position of 173
                        // use parseText
                        var parsed = parseText.remove(lang.lyric)
                        console.log(parsed)
                        // For Each then we need to find the true length of non diacritic elements

                        //let stringarr = ((typeof element == 'string') ? element.split("") : element[0].split(""));
                        //let stringarr = ( languageLineCombinedLyric.split( String.fromCharCode(173) ) );
                        let stringarr = parsed.splitLyrics
                        // 'aaa','bbb','ccccc'
                        if (!(stringarr.length == line.numbers.length || stringarr.length-1 == line.numbers.length)) {
                            console.error("What is happening, these should match")
                        }

                        let elementAsArray = lineModulate.diacriticChecker(parsed.lyric, 0) // lets work with the 'true' length array
                        lyric[key] = elementAsArray;

                        numberStartLocations[key] = parsed.numberStartLocations;
                    }
                }

                var pipFormatter = {}; //var pipFormats = {'0':'abc', '1':'pqr', '2':'xyz'};
                var range = {}; // {min/max/percentage: [increment, 1]}

                // setup pipFormatter
                // we want to group diacritic characters together
                for (const tag in lyric) {
                    pipFormatter[tag] = {};
                    range[tag] = {};
                    if (Object.hasOwnProperty.call(lyric, tag)) {
                        if (typeof(lyric[tag])) {
                            var langArray = lyric[tag]
                            let totalCharacters = langArray.length;
                            let increment = (Math.floor((100 / totalCharacters) * 10)) / 10
                            var i = 0;
                            // pipFormatter = {'min': [0,increment]}
                            range[tag]['min'] = [0, 1];
                            while (i < totalCharacters) {
                                // {('0':'abc')}
                                let currentChar = langArray[i]; // get char from position 0, insert to position 1
                                pipFormatter[tag][i.toString()] = currentChar;

                                // range
                                // {'50%': [1,1]}
                                let currentPlace = (increment * i) // starts at 0
                                let nextPlace = (increment * (++i))
                                range[tag][`${nextPlace}%`] = [i, 1];
                            };
                            pipFormatter[tag][i.toString()] = "";
                            range[tag]['max'] = [i, 1];
                            if (!( numberStartLocations[tag].length === noteList.length )){
                                console.error("We don't have matching expectations for how many numbers there should be. Something went wrong")
                            }
                            self.makeSlider(tag, pipFormatter[tag], range[tag], numberStartLocations[tag], noteList)
                        }
                    }
                };
            },
            makeSlider: function(tag, pipFormats, lyricRange, numberStartLocations, chordDataObject) {
                if(numberStartLocations.length != chordDataObject.length){
                    console.error("We don't have matching expectations for how many numbers there should be. Something went wrong")
                    numberStartLocations.pop()
                } else //{ // is new data
                //     numberStartLocations.splice(0,0,'')
                //     numberStartLocations.pop()
                // }
                while(chordDataObject.length > numberStartLocations.length){
                    numberStartLocations.push(lyricRange.max[0])
                }
                var options = {}
                options.range = lyricRange;
                options.pips= {
                    mode: 'range',
                    format: {
                        to: function(a) {
                            return pipFormats[a];
                        }
                    }
                }
                if (chordDataObject.length){
                    options.tooltips = chordDataObject;
                    options.start= numberStartLocations;
                    options.tooltips= chordDataObject;
                } else {
                    // no chords on this song
                    options.start= [lyricRange.max[0]];
                }
                //
                var slider = self.$(`.slider-${tag}`)[0];
                if (slider) {
                    if (slider.noUiSlider) {
                        // If already exists, clear it
                        slider.noUiSlider.destroy();
                    }   // Make the slider
                    console.log ("working: " + tag )
                    noUiSlider.create(slider, options);
                } else {
                    console.error("no slider BEFORE destroy")
                    debugger
                }
                if (slider == undefined) {
                    console.log ("broken: " + tag)
                    slider = self.$(`#sliderContainer-${tag}`)[0];  
                    console.log (slider)
                    // var slider = self.$(`.slider-${tag}`)[0];  
                    debugger
                } else {
                    // working fine
                }
                // noUiSlider.create(slider, {
                //     start: numberStartLocations,
                //     tooltips: chordDataObject,
                //     range: lyricRange,
                //     pips: {
                //         mode: 'range',
                //         format: {
                //             to: function(a) {
                //                 return pipFormats[a];
                //             }
                //         }
                //     }
                // });
            },
            lineEditPopup: function(tag) {
                tag = tag || defaultLanguage;
                var phraseBreakLocations = {};
                
                var langLine = ""
                if(!phraseBreakLocations[tag]){ // if is not set
                    phraseBreakLocations[tag] = [];
                }
                line.phrases.forEach(phrase => {
                    if (phrase[tag]) {
                        langLine += phrase[tag];
                        let phraseArr = phrase[tag].split("")
                        let elementAsArray = lineModulate.diacriticChecker(phraseArr, 0);
                        phraseBreakLocations[tag].push(elementAsArray.length);
                    }
                });

                // remove number elements
                var parsed = parseText.remove(langLine)
                var el = `<div class="popup">
                        <div class="block">
                            <strong><h3>*edit line text here</h3></strong>
                            <div class='tag'>${tag}</div>
                            <form class="item-content item-input line-form" id="line-form">
                                <div class="item-inner">
                                    <div class="item-input-wrap" id="item-input-wrap">
                                    <input type="text" class="lineText" style=''value="${parsed.lyric}"/>
                                    <span class="input-clear-button"></span>
                                    </div>
                                </div>
                            </form>
                            <p><a  href="#" class="col popup-close button button-fill">*preview</a></p>
                        </div>
                    </div>`
                var a = app.popup.create({
                    content:el,
                    'tag': tag,  
                    closeByBackdropClick: true,
                    on: {
                        opened: function (popup) {
                        console.log('Panel opened')
                        },
                        opened: function (popup) {
                            console.log('Popup opened');
                        },
                        close: function (popup) {
                            var tag = self.$$(".tag")[0].innerHTML
                            var formData = self.$$(".lineText")[0].value
                            // put numbers back
                            parseText.add(formData, parsed.numberPositions).then((newLyric) => {
                                self.updateLine(newLyric, tag,phraseBreakLocations)
                            });
                        },
                    }
                }); 
                a.open();
            },
            updateLine: function(data,tag,phraseBreakLocations){
                if (self.validateTag(tag)){
                    //update line and refresh
                    var lineArr = lineModulate.diacriticChecker(data.split(""), 0)
                    var chordPlacment = phraseBreakLocations[tag]

                    let i = 0
                    while (i < line.phrases.length) {
                        let expectPhraseLength = chordPlacment[i];
                        // the array may be shorter than we expect, allow phrases to be at end of array
                        // at end of array, include any extra characters
                        // if exists,           is less than remaining length,           on last index, grab remainder => set. otherwise is remaining length. remaining length can be 0
                        let phraseLength = ((expectPhraseLength && expectPhraseLength < lineArr.length-1 && (i+1) < line.phrases.length) ? expectPhraseLength : (lineArr.length));
                        let newPhrase = lineArr.splice(0,phraseLength).join('');

                        //set it
                        line.phrases[i][tag] = newPhrase;
                        song.lyrics.verses[verseId].lines[lineId].phrases[i++][tag] = newPhrase;
                    }
                    self.clearSliders();
                    self.$setState({
                        loading: false,
                        song: song,
                        line: line,
                        savable: true
                    }, () => {
                        self.displayLyricSliders()
                        // User will need to save....
                    });                   
                }
            },
            validateTag: function(tag){
                if (languages.includes(tag)){
                    return true;
                }
                console.error("This should never fail")
                return false
            },
            backChecker: function(e){
                let newStatus = app.form.convertToData('#edit-donation')
                // Dirty is True if they don't match
                return (JSON.stringify(saveStatus) != JSON.stringify(newStatus))
                ev.preventDefault();
                // If status means form can be edited AND If form is dirty
                // then ask for confirmation 
                // complete 1581051573142 Submitted 1581051573215
                if (isDirty()) {
                    // 
                    var dialog = app.dialog.create({
                        backdrop: true,
                        closeByBackdropClick: false,
                        title: "<t>Leave this page?</t>",
                        text: "<t>Do you want to save your changes?</t>",
                        buttons: [{
                                text: "<t>Don't Save</t>",
                                onClick: (dialog, ev) => {
                                    this.$router.back();
                                }
                            },
                            {
                                text: "<t>Save</t>",
                                onClick: (dialog, ev) => {
                                    app.dialog.close()
                                    setStatus()
                                }
                            }
                        ],
                        verticalButtons: true
                    });
                    dialog.open();
                }
                // If form is empty, go back immediately
                else {
                    this.$router.back();
                }
            }
        }
    }
</script>