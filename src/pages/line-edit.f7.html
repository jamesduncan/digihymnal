<template>
    <div class="page">
        <div class="navbar">
            <div class="navbar-bg"></div>
            <div class="navbar-inner sliding">
                <div class="left">
                    <a {{#if loading}}href=""{{else}}href="/song/view/{{this.songId}}/"{{/if}} class="link back" data-force="true" data-ignore-cache="true">
                        <i class="icon icon-back"></i> 
                        <span class="if-not-md" >{{#if loading}}Back{{else}}{{translate "Back"}}{{/if}}</span>
                    </a>
                </div>
                <div class="title">{{#if loading}}{{else}} {{song.title[defaultLanguage]}} : {{@root.verseLabel}} {{/if}}</div>
            </div>
        </div>
        <div class="page-content hide-navbar-on-scroll">
            {{#js_if "!@root.loading"}}
                <div class="block block-strong" style="margin-bottom: 10px; overflow: hidden;">
                    <div class="menu">
                        <div class="menu-inner no-margin-padding">
                            <!-- Stepper element -->
                            <div class="stepper stepper-large stepper-fill" style="display: none; margin-left: auto; height: 40px;">
                                <div class="stepper-button-minus"></div>
                                <div class="stepper-input-wrap">
                                    <input type="text" value="{{transpose song.key @root.steps}}" readonly>
                                </div>
                                <div class="stepper-button-plus"></div>
                            </div>
                            <div>
                                <div class="menu-item">
                                    <div class="menu-item-content icon-only">
                                        <div class="menu-item-content">
                                            <a @click="save" class="col button button-fill">
                                                <i class="text-color-gray fa-bigger fas fa-save"></i>
                                            </a>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="menu-item">
                                <div class="menu-item-content icon-only">
                                    <div class="menu-item-content">
                                        <a class="col button button-fill{{#if firstLine}} disabled{{/if}}" @click="prevLine">
                                            <i class="text-color-gray fas fa-bigger fa-arrow-left"></i>
                                        </a>
                                    </div>
                                </div>
                            </div>
                            <!--
                            goto next
                            -->
                            <div class="menu-item">
                                <div class="menu-item-content icon-only">
                                    <div class="menu-item-content">
                                        <a @click="nextLine" class="col button button-fill{{#js_if "@root.lastLine && @root.lastVerse"}} disabled{{/js_if}}">
                                            <i class="text-color-gray fa-bigger fas fa-arrow-right"></i>
                                        </a>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="item-title item-label">
                                Chord tools:
                            </div>
                            <!--
                                phrase
                            -->
                            <div class="menu-item">
                                <div class="menu-item-content icon-only">
                                    <div class="menu-item-content">
                                        <a @click="addPhrase" class="col button">
                                            <i class="text-color-gray fas fa-plus"></i>
                                        </a>
                                    </div>
                                </div>
                            </div>
                            <!--
                                delete phrase, only show if totally empty??????
                            -->
                            <div class="menu-item">
                                <div class="menu-item-content icon-only">
                                    <div class="menu-item-content">
                                        <a @click="deletePhrase" class="col button">
                                            <i class="text-color-gray fas fa-trash"></i>
                                        </a>
                                    </div>
                                </div>
                            </div>
                            <!--
                            LINE
                            -->
                            <div class="item-title item-label">
                                <t>Line tools:</t>
                            </div>
                            <div class="menu-item">
                                <div class="menu-item-content icon-only">
                                    <div class="menu-item-content">
                                        <a @click="addLine" class="col button button-fill">
                                            <i class="text-color-gray fa-bigger fas fa-plus"></i>
                                        </a>
                                    </div>
                                </div>
                            </div>
                            <div class="menu-item">
                                <div class="menu-item-content icon-only">
                                    <div class="menu-item-content">
                                        <a class="col button button-fill" @click="deleteLine">
                                            <i class="text-color-gray fa-bigger fas fa-trash"></i>
                                        </a>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="sheet">
                        <div class="song">
                            <div class="verse">
                                <div class="line" id="edit-line">
                                    <!-- -->
                                    {{ printEachPhrase @root.line @root.languages }}
                                    <!-- -->
                                    {{ printLyric @root.line}}
                                </div>
                            </div>
                        </div>
                    </div>
                {{#js_if "@root.savable"}}
                    <p><a @click="save"  class="col popup-close button button-fill">*Save</a></p>
                {{/js_if}}
                </div>
                <div class="block text-align-right text-color-gray" style="margin-top: 10px;">
                    {{song.author[defaultLanguage]}}
                </div>
            {{/js_if}}
        </div>
    </div>
</template>
<style>
    .noUi-marker {
        height: 0 !important;
    }

    .no-margin-padding {
        margin: 0;
        padding: 0;
    }

    .fa-bigger {
        font-size: larger;
    }

    .song {
        transform-origin: left top;
    }

    .line {
        margin-bottom: 20px;
    }

    .phrase {
        position: relative;
        display: inline-block;
        margin: 55px 10px 0 0;
        min-width: 20px;
    }

    .chord,
    .number {
        top: -55px;
        background: var(--f7-theme-color);
        border-radius: 3px;
        min-width: 20px;
        height: 20px;
        line-height: 20px;
        text-align: center;
        color: white;
        font-weight: bold;
        display: inline-block;
        padding: 0 2px;
        margin-right: 5px;
        position: absolute;
        padding: 2px;
    }

    .number {
        top: -25px;
        border-radius: 100%;
        width: 20px;
        height: 20px;
        padding: 2px;
        background: var(--f7-color-blue);
        font-family: 'Notes', monospace;
    }

    .noNumbers,
    .noChords {
        margin-top: 30px !important;
    }

    .noNumbers.noChords {
        margin-top: 10px !important;
    }

    .noNumbers .chord,
    .noChords .chord {
        top: -30px;
    }
</style>
<script>
    var songId
    var loading
    var savable = false;
    var verseId
    var verseLabel
    var lineId
    var languages
    var lyricList
    var line
    var song
    var app
    var lastVerse
    var lastLine
    var firstLine
    var chordStartLocations
    import DataManager from '../data/dataManager';
    import Song from '../data/song';
    import noUiSlider from 'nouislider';
    import 'nouislider/dist/nouislider.css';
    // //  the namespace:
    // import * as noUiSlider from 'nouislider';
    // import 'nouislider/dist/nouislider.css';

    // // Alternatively, you can include both files:
    // <link href="nouislider.css" rel="stylesheet">
    // <script src="nouislider.js"><//////script>

    import Preference from "../data/preference";
    const dataManager = new DataManager();
    const songCollection = new Song();
    const preference = new Preference();

    // Import locales
    const locale = require('../js/locales.js');

    var initScale = 1;
    var lyric1;
    var lyric2;
    var defaultLanguage;
    var deviceWidth = window.innerWidth;
    var self = this;
    if (deviceWidth >= 700) {
        initScale = 2;
    } else if (deviceWidth >= 500) {
        initScale = 1.5;
    }
    var steps = 0;

    export default {
        // Component Data
        data: function() {
            // Must return an object
            self = this;
            return {
                loading: true,
                savable: savable,
                lastVerse: false,
                lastLine: false,
                firstLine: false,
                showNumber: false,
                showChord: false
            }
        },
        // Page Events
        on: {
            pageInit: function(e, page) {
                self = this;
                app = self.$app;
                var $form = this.$('#edit-line')
                
                songId = this.$route.params.songId;
                verseId = this.$route.params.verseId;
                lineId = this.$route.params.lineId;
                
                // get global savable
                self.savableUpdate(app.savable);

                preference.getLanguage().then((languageCode) => {
                    lyric1 = languageCode;
                    defaultLanguage = languageCode;
                    languages = [];
                    lyricList = []
                    var result = app.song;
                    var translationLangs = Object.keys(result.lyrics.verses[verseId].lines[lineId].phrases[0]);
                    //var translationLangs = Object.keys(result.title);
                    locale.customLocales.forEach((item) => {
                        if (translationLangs.indexOf(item.tag) > -1) {
                            if (item.tag == lyric1) {
                                item.default = true;
                            }
                            languages.push(item.tag)
                        }
                    });
                    line = result.lyrics.verses[verseId].lines[lineId]

                    // check if last line
                    lastLine = (lineId >= (result.lyrics.verses[verseId].lines.length - 1));
                    lastVerse = (verseId >= (result.lyrics.verses.length - 1));
                    // song is used to get next line
                    song = result

                    self.$setState({
                        loading: false,
                        savable: savable,
                        songId: songId,
                        lastLine: lastLine,
                        lastVerse: lastVerse,
                        verseLabel: result.lyrics.verses[verseId].label,
                        firstLine: (lineId == 0 && verseId == 0),
                        song: song,
                        // verse: result.verse[verseId],
                        line: line,
                        steps: steps,
                        languages: languages,
                        lyricList: lyricList,
                        defaultLanguage: defaultLanguage
                    }, () => {
                        self.$(".song")[0].style.transform = "scale(" + initScale + ")";
                        self.$(".sheet")[0].style.height = (self.$(".song")[0].offsetHeight * initScale) + "px";

                        // make the sliders
                        self.displayLyricSliders()

                        languages.forEach(lang => {
                            line.phrases.forEach(phrase => {
                                lyricList.push({
                                    "tag": lang,
                                    "lyric": line[lang]
                                })
                            });
                        });

                        var stepper = app.stepper.create({
                            el: '.stepper',
                            value: steps,
                            min: 0,
                            max: 11,
                            wraps: true,
                            on: {
                                change: function(e) {
                                    steps = e.value;
                                    self.$setState({
                                        steps: steps,
                                    });
                                }
                            }
                        });
                    });
                });
            },
        },
        methods: {
            zoomIn: function(e) {
                initScale += 0.05;
                this.$(".song")[0].style.transform = "scale(" + initScale + ")";
                this.$(".sheet")[0].style.height = (this.$(".song")[0].offsetHeight * initScale) + "px";
            },
            zoomOut: function(e) {
                initScale -= 0.05;
                this.$(".song")[0].style.transform = "scale(" + initScale + ")";
                this.$(".sheet")[0].style.height = (this.$(".song")[0].offsetHeight * initScale) + "px";
            },
            save: function(e) {
                var $form = this.$('#edit-line')
                var $ = $form.find("select[name='']") //relation
                if (!self.$app.input.validateInputs('#edit-line')) {
                    // TODO make this say what the error is
                    self.$app.dialog.alert('Please correct your entries.');
                    console.error('<t>Please correct your entries.</t>');
                } else {
                    let newData = song;

                    // How much metadata?
                    let metadataLength = (self.$('.metadata')[0].children).length;
                    var newLanguageLineData = {}
                    
                    var chordPlacerIndex = 0; // if a new first phrase is chordless, this starts on second phrase

                    languages.forEach(langTag => { // selected language
                        newLanguageLineData[langTag] = self.parseLanguageText(langTag);
                        // this logic tries to account for going from a chord at the beginning, to forcing a chordless phrase
                        if ( metadataLength == (newLanguageLineData[langTag].length - 1)){ // This means there is a new chordless phrase
                            // Other language might have already been inserted, 
                            if (Object.hasOwnProperty.call(newData.lyrics.verses[verseId].lines[lineId].phrases[0], 'chord')) { // if 0 has chord, need to insert new chordless phrase
                                let newPhrase = {}
                                languages.forEach(langTag => {newPhrase[langTag] = ''}); // make / insert new chordless phrase
                                newData.lyrics.verses[verseId].lines[lineId].phrases.splice(0, 0, newPhrase);
                            } 
                            chordPlacerIndex = 1;
                        } else if (chordPlacerIndex || newLanguageLineData[langTag].length == ( metadataLength - 1 ) ) { // this language doesn't have no-chord phrase, another one does.
                            newLanguageLineData[langTag].splice(0,0,'');
                        };
                        let i = 0;
                        var expectedLength = newData.lyrics.verses[verseId].lines[lineId].phrases.length
                        if(newLanguageLineData[langTag].length != expectedLength){
                            if(expectedLength == 1){ // we may not have added chord, and still be trying to save.
                                newLanguageLineData[langTag][0] = newLanguageLineData[langTag].join('');
                                while(newLanguageLineData[langTag].length != expectedLength){
                                    newLanguageLineData[langTag].pop()
                                }
                            }else if(newLanguageLineData[langTag].length == 1 + expectedLength){ // only a difference of one means theres a chord at beginning of phrase now.
                                if (newLanguageLineData[langTag].pop()!=''){
                                    console.error("Why is this happening?")
                                    debugger;
                                }
                            }else{
                                console.error("Why is this happening?")
                                debugger
                            }
                        }
                        while (i < newLanguageLineData[langTag].length){ // insert this language to the song data
                            const element = newLanguageLineData[langTag][i];
                            newData.lyrics.verses[verseId].lines[lineId].phrases[i][langTag] = element;
                            i++;
                        }
                    });
                    var i = 0;

                    while (i < metadataLength) {
                        let id = ('.chord').concat(i)
                        let chord = self.$(id)[0]//.value // self.$('.chord1').firstElementChild.value
                        if (chord) { // our template will not create form if it's supposed to be blank
                            // setting chord
                            newData.lyrics.verses[verseId].lines[lineId].phrases[chordPlacerIndex]['chord'] = chord.value;
                            // setting number
                            id = ('.number').concat(i) // '.number1'
                            let number = self.$(id)[0].value 
                            newData.lyrics.verses[verseId].lines[lineId].phrases[chordPlacerIndex]['number'] = number
                        }
                        chordPlacerIndex++;
                        i++;
                    };
                    // save
                    line = newData.lyrics.verses[verseId].lines[lineId];
                    song = newData;
                    app.song = newData;
                    songCollection.db.setItem(songId, newData);
                    self.savableUpdate(false);
                    self.clearSliders();
                    self.$setState({
                        loading: false,
                        song: newData,
                        line: newData.lyrics.verses[verseId].lines[lineId]
                    }, () => {
                        self.displayLyricSliders();
                    });
                    // send line changes to server
                    dataManager.putLine(songId, verseId, lineId, newData.lyrics.verses[verseId].lines[lineId])
                        .then(responseText => alert(JSON.stringify(responseText)));
                
                }
            },
            parseLanguageText: function(tag, languageLine, chordArray){
                // I need the full string "Twinkle, twinkle, little star"
                // I need placment of phrase breaks ["0.00", "10.00", "15.00"]
                // return [('Twinkle, tw'),('inkle'),(', little star')]
                if(!chordArray){ // get from dom
                    try {
                        chordArray = this.$$(`#slider-${tag}`)[0].noUiSlider.get()
                    } catch (error) {
                        console.error(error)
                    }
                    if (!chordArray) {
                        console.error({"no div for tag":tag})
                    }
                }
                if(!languageLine){ // get from global var
                    try {
                        languageLine = ''
                        line.phrases.forEach(phrase => {
                            if (Object.hasOwnProperty.call(phrase, tag)) {
                                languageLine = languageLine.concat(phrase[tag]);   
                            }
                        });
                    } catch (error) {
                        console.error(error)
                    }
                    if (!languageLine) {
                        console.error({"no line data for tag":tag});
                    }
                }
                var phraseArray = [] ;// ["Twin","kle, twinkle,", " little star"]
                
                if (typeof chordArray === 'string'){// there's only the one chord
                    if (parseInt(chordArray) != 0){ // we need two phrases
                        var parsedLineArr = self.diacriticChecker(languageLine.split(""), 0);
                        phraseArray.push( (parsedLineArr.splice(0, parseInt(chordArray) )).join("") ); 
                        phraseArray.push( parsedLineArr.join("") ); // remaining
                    } else {
                        phraseArray.push(languageLine);
                    }
                } else {
                    if( typeof languageLine == 'string'){
                        languageLine = languageLine.split("");
                    }
                    var parsedLineArr =  self.diacriticChecker(languageLine, 0);
                    var lastPhraseLength = 0;
                    var firstChord = true;
                    var totalPhrases = chordArray.length

                    var i = 0;
                    while (chordArray[i]) {
                        let chord = (chordArray[i]);
                        var currentIndexValue = parseInt(chord);
                        var currentPhraseLength
                        // to chop off index
                        
                         
                        if(firstChord && currentIndexValue != 0){ // first and skipping phrase
                            firstChord = false;
                            // put a chordless phrase end of chordless is start of next
                            let toInsert = (parsedLineArr.splice(0,currentIndexValue)).join(""); // splice(start, deleteCount)
                            totalPhrases++;
                            phraseArray.push( toInsert );
                        } else {
                            firstChord = false;
                        }
                            
                            //else if(firstChord && currentIndexValue === 0){ // There is always a chordless phrase
                        //     phraseArray.push( '' )
                        // }
                        if (totalPhrases == phraseArray.length+1){ // we're on last chord, claim rest of phrase
                            currentPhraseLength = parsedLineArr.length;
                            i++;
                        } else { // middle
                            currentPhraseLength = parseInt(chordArray[i+1]) - currentIndexValue;
                            i++;
                        }
                        
                        
                        lastPhraseLength = currentPhraseLength;
                        let toInsert = (parsedLineArr.splice(0,currentPhraseLength)).join(""); // splice(start, deleteCount)
                        phraseArray.push( toInsert );
                    }
                }
                return phraseArray;
            },
            nextLine: function(e) {
                // only get index forward if it exists in song
                if (lastLine && !lastVerse) { // if at end of NOTlastVerse, check next verse
                    lastVerse = ((verseId + 1) >= (song.lyrics.verses.length - 1)); // is next verse last verse?
                    lastLine = ((song.lyrics.verses[parseInt(verseId) + 1].lines[1]) == undefined); // is there only one line in next verse?
                    ++verseId;
                    lineId = 0;
                    verseLabel = song.lyrics.verses[verseId].label;
                } else {
                    // check if last line
                    lastLine = ((lineId + 1) >= (song.lyrics.verses[verseId].lines.length - 1));
                    ++lineId;
                }
                // update variable
                line = song.lyrics.verses[verseId].lines[lineId]
                self.clearSliders()
                self.$setState({
                    loading: false,
                    firstLine: (lineId == 0 && verseId == 0),
                    lastLine: lastLine,
                    lastVerse: lastVerse,
                    verseLabel: verseLabel,
                    line: song.lyrics.verses[verseId].lines[lineId]
                }, () => {
                    self.clearSliders()
                    self.displayLyricSliders()
                });
            },
            prevLine: function(e) {
                if (lineId == 0) {
                    --verseId
                    lineId = song.lyrics.verses[verseId].lines.length - 1
                    // update variable
                    lastVerse = ((verseId) >= (song.lyrics.verses.length - 1)); // is next verse last verse?
                    verseLabel = song.lyrics.verses[verseId].label;
                } else {
                    --lineId
                }
                line = song.lyrics.verses[verseId].lines[lineId]
                self.clearSliders()
                self.$setState({
                    loading: false,
                    firstLine: (lineId == 0 && verseId == 0),
                    lastLine: false,
                    verseLabel: verseLabel,
                    lastVerse: lastVerse,
                    line: song.lyrics.verses[verseId].lines[lineId]
                }, () => {
                    self.displayLyricSliders()
                });
            },
            deleteLine: function(e) {
                // TODO pre-delete confirmation prompt
                let newData = song
                // At index, remove one element
                let deletedLine = newData.lyrics.verses[verseId].lines.splice(lineId, 1)

                // default to changing nothing, wil auto set to the right line
                if ((verseId != 0) && lineId == 0 && (0 == newData.lyrics.verses[verseId].lines.length)) {
                    // if last remaining line of not last verse
                    let deletedVerse = newData.lyrics.verses.splice(verseId, 1)
                    if (lastVerse) {
                        --verseId;
                    }
                    lineId = newData.lyrics.verses[verseId].lines.length - 1;
                } else if (lastLine) {
                    // set lineId to an existing line
                    --lineId;
                } else {
                    console.error("You tried to delete the last line of the last verse!!!")
                }

                song = newData;
                app.song = newData;
                line = song.lyrics.verses[verseId].lines[lineId]
                self.savableUpdate(true);
                //songCollection.db.setItem(songId, newData)
                self.clearSliders()
                self.$setState({
                    line: newData.lyrics.verses[verseId].lines[lineId],
                    firstLine: (lineId == 0 && verseId == 0),
                    lastLine: (lineId >= (song.lyrics.verses[verseId].lines.length - 1)),
                    song: newData,
                    loading: false,
                }, () => {
                    self.displayLyricSliders()
                });
            },
            addVerse: function(e) {
                let newData = song;
                var phraseTemplate = Object.assign({}, newData.lyrics.verses[verseId].lines[lineId].phrases[0]);
                for (const tag in phraseTemplate) {
                    if (Object.hasOwnProperty.call(phraseTemplate, tag)) {
                        // set all data inside empty
                        phraseTemplate[tag] = "*"
                    }
                };
                var lineObj = {
                    "lines": [{
                        'phrases': [phraseTemplate]
                    }]
                }; // make a new template

                var currentVerse = newData.lyrics.verses[verseId];

                var newId = ((parseInt(currentVerse.id) !== NaN) ? (parseInt(currentVerse.id) + 1) : 1);

                // 'verse 3'
                let myArr = currentVerse.label.split(" ");
                let verseNumber = (typeof(parseInt(myArr[(myArr.length - 1)])) == 'number' ? (parseInt(myArr[(myArr.length - 1)])) : 1)

                var newLabel = 'verse'.concat(verseNumber);

                var newVerse = {
                    "lines": lineObj,
                    "label": newLabel,
                    "id": newId
                }

                newData.lyrics.verses.push(newVerse);
                song = newData;
                app.song = newData;
                line = song.lyrics.verses[verseId].lines[lineId];
                self.savableUpdate(true);
                //songCollection.db.setItem(songId, newData);

                // send ovreall song changes to server
                dataManager.putSong(songId, newData)
                    .then(responseText => alert(JSON.stringify(responseText)));
                lastLine = true;
                song = newData;
                line = newData.lyrics.verses[verseId].lines[lineId];
                self.clearSliders();
                self.$setState({
                    loading: false,
                    song: newData,
                    lastLine: true,
                    line: newData.lyrics.verses[verseId + 1].lines[0]
                }, () => {
                    self.displayLyricSliders()
                });
            },
            splitVerse: function(e) {
                let newData = song;

                var currentVerse = newData.lyrics.verses[verseId];

                // 'verse 3'
                let myArr = currentVerse.label.split(" ");
                let verseNumber = (typeof(parseInt(myArr[(myArr.length - 1)])) == 'number' ? (parseInt(myArr[(myArr.length - 1)])) : 1)
                var newLabel = 'verse'.concat(verseNumber);

                let toRemove = (currentVerse.lines.length - lineId)
                var lineObj = currentVerse.lines.splice(lineId, toRemove, currentVerse);

                var newVerse = {
                    "lines": lineObj,
                    "label": newLabel,
                    "id": newId
                }

                //let newLine = {'phrases': [phraseTemplate]};
                let vArray = newData.lyrics.verses

                vArray.splice(verseId, 1, currentVerse); // update current to be missing lines...

                let workingIndex = ++verseId; 
                vArray.splice(workingIndex, 0, newLine);// after current

                // clean up labels
                vArray.forEach(verse => {
                    if (Object.hasOwnProperty.call(verse, label)) {
                        const element = verse[label];
                        if(element!='chorus'){
                            //split it and increase the counter
                        }
                        
                    }
                });
                newData.lyrics.verses = vArray;

                song = newData;
                app.song = newData;
                line = song.lyrics.verses[verseId].lines[lineId];
                self.savableUpdate(true)
                //songCollection.db.setItem(songId, newData);

                // send ovreall song changes to server
                dataManager.putSong(songId, newData)
                    .then(responseText => alert(JSON.stringify(responseText)));
                lastLine = true;
                song = newData;
                line = newData.lyrics.verses[verseId].lines[lineId];
                self.clearSliders();
                self.$setState({
                    loading: false,
                    song: newData,
                    lastLine: true,
                    line: newData.lyrics.verses[verseId + 1].lines[0]
                }, () => {
                    self.displayLyricSliders()
                });
            },
            addLine: function(e) {
                let newData = song;
                // At index, add one element

                var phraseTemplate = Object.assign({}, newData.lyrics.verses[verseId].lines[lineId].phrases[0]);

                for (const tag in phraseTemplate) {
                    if (Object.hasOwnProperty.call(phraseTemplate, tag)) {
                        // set all data inside empty
                        phraseTemplate[tag] = "*"
                    }
                };

                let lineArray = newData.lyrics.verses[verseId].lines;
                let workingIndex = ++lineId; // tack it onto after current
                let newLine = {'phrases': [phraseTemplate]};
                // insert item into arr at the specified index (deleting 0 items first, it's just an insert).
                lineArray.splice(workingIndex, 0, newLine);
                newData.lyrics.verses[verseId].lines = lineArray;
                app.song = newData;
                self.savableUpdate(true)
                //songCollection.db.setItem(songId, newData);

                // send verse changes to server
                dataManager.putVerse(songId, verseId, newData.lyrics.verses[verseId])
                    .then(responseText => alert(JSON.stringify(responseText)));
                // lastLine = (lineId===(newData.lyrics.verses[verseId].lines.length-1))
                song = newData;
                line = song.lyrics.verses[verseId].lines[lineId];
                self.clearSliders();
                self.$setState({
                    loading: false,
                    song: newData,
                    line: newData.lyrics.verses[verseId].lines[lineId]
                }, () => {
                    self.displayLyricSliders();
                });
            },
            addPhrase: function(e) {
                let newData = song
                // At index, add one element

                var phraseArray = newData.lyrics.verses[verseId].lines[lineId].phrases
                var workingIndex = phraseArray.length - 1;
                phraseArray.push({
                    ...phraseArray[workingIndex]
                }); // extend by copying the last -will only keep object structure
                workingIndex = phraseArray.length - 1;

                for (const tag in phraseArray[workingIndex]) {
                    if (Object.hasOwnProperty.call(phraseArray[workingIndex], tag)) {
                        // set all data inside empty
                        phraseArray[workingIndex][tag] = ""
                    }
                }
                
                // if (!Object.hasOwnProperty.call(phraseArray[workingIndex], 'chord')) {
                phraseArray[workingIndex].chord = '*';
                phraseArray[workingIndex].number = 1;
                // }

                newData.lyrics.verses[verseId].lines[lineId].phrases = phraseArray
                app.song = newData;
                self.savableUpdate(true);
                //songCollection.db.setItem(songId, newData)
                song = newData;
                line = song.lyrics.verses[verseId].lines[lineId];
                self.clearSliders()
                self.$setState({
                    loading: false,
                    song: newData,
                    line: newData.lyrics.verses[verseId].lines[lineId]
                }, () => {
                    self.displayLyricSliders()
                });
            },
            savableUpdate: function(bool) {
                if (typeof(bool) != 'boolean'){
                    bool = false;
                }
                app.savable = bool;
                savable = bool;
                self.$setState({
                    savable: bool
                });
            },
            deletePhrase: function(e) {
                if( line.phrases.length <= 1 ){
                    return;
                }
                let newData = song;

                var workingIndex = (newData.lyrics.verses[verseId].lines[lineId].phrases).length - 1;
                let deletedPhrase = newData.lyrics.verses[verseId].lines[lineId].phrases.splice(workingIndex--, 1)[0]
                // merge the lyrics
                for (const tag in deletedPhrase) {
                    if (Object.hasOwnProperty.call(deletedPhrase, tag)) {
                        if (tag != 'chord' && tag != 'number'){
                            const element = deletedPhrase[tag];
                            newData.lyrics.verses[verseId].lines[lineId].phrases[workingIndex][tag] += element;
                        }
                    }
                }

                line = newData.lyrics.verses[verseId].lines[lineId]
                app.song = newData;
                self.savableUpdate(true)
                self.clearSliders()
                self.$setState({
                    loading: false,
                    song: newData,
                    line: newData.lyrics.verses[verseId].lines[lineId]
                }, () => {
                    self.displayLyricSliders()
                });
            },
            clearSliders: function() {
                languages.forEach(languageCode => {
                    var slider = self.$(`.slider-${languageCode}`)[0];
                    if (slider) {
                        if (slider.noUiSlider) {
                            slider.noUiSlider.destroy();
                        }
                    }
                });
            },
            displayLyricSliders: function(e) {
                // 
                var lyric = {};
                chordStartLocations = {}; //  {'en':[1,5,12]}
                var chordList = [];           // tooltips: [ {to: function() {return "2<br/>A";} } ]

                // init each language
                languages.forEach(languageCode => {
                    chordStartLocations[languageCode] = [];
                    lyric[languageCode] = [];
                });

                line.phrases.forEach(phrase => {
                    let meta = {}; // chord and number
                    for (const key in phrase) {
                        if (Object.hasOwnProperty.call(phrase, key)) {
                            const element = phrase[key];
                            if (key == 'chord') {
                                meta.chord = element
                            } else if (key == 'number') {
                                meta.number = element
                            } else { // language
                                let elementAsArray = self.diacriticChecker(element.split(""), 0) // lets work with the 'true' length array
                                if(lyric[key]){
                                    lyric[key] = lyric[key].concat(elementAsArray);
                                } else{
                                    lyric[key] = elementAsArray;
                                }
                                // 
                                var chordEndIndex // falsy
                                if (chordStartLocations[key]){  // if already exists
                                    chordEndIndex = chordStartLocations[key].length;
                                }else{
                                    chordStartLocations[key] = [];
                                    chordEndIndex = 0;
                                }
                                if (chordEndIndex == 0) {
                                    chordStartLocations[key].push(elementAsArray.length)
                                } else {
                                    chordStartLocations[key].push(chordStartLocations[key][chordEndIndex - 1] + elementAsArray.length)
                                }
                            }
                        }
                    }
                    if (meta.chord){ // if meta is set
                        // push to chord/num list
                        chordList.push({
                            'to': function() {
                                return `${meta.chord}<br/>${meta.number}`
                            }
                        })
                    }
                });

                var pipFormatter = {}; //var pipFormats = {'0':'abc', '1':'pqr', '2':'xyz'};
                var range = {}; // {min/max/percentage: [increment, 1]}

                for (const tag in lyric) {
                    pipFormatter[tag] = {};
                    range[tag] = {};
                    if (Object.hasOwnProperty.call(lyric, tag)) {
                        if (typeof(lyric[tag])) {
                            var langArray = lyric[tag]
                            let totalCharacters = langArray.length;
                            let increment = (Math.floor((100 / totalCharacters) * 10)) / 10
                            var i = 0;
                            // pipFormatter = {'min': [0,increment]}
                            range[tag]['min'] = [0, 1];
                            while (i < totalCharacters) {
                                // {('0':'abc')}
                                let currentChar = langArray[i]; // get char from position 0, insert to position 1
                                pipFormatter[tag][i.toString()] = currentChar;

                                // range
                                // {'50%': [1,1]}
                                let currentPlace = (increment * i) // starts at 0
                                let nextPlace = (increment * (++i))
                                range[tag][`${nextPlace}%`] = [i, 1];
                            };
                            pipFormatter[tag][i.toString()] = "";
                            range[tag]['max'] = [i, 1];
                            self.makeSlider(tag, pipFormatter[tag], range[tag], chordStartLocations[tag], chordList)
                        }
                    }
                };
            },
            makeSlider: function(tag, pipFormats, lyricRange, chordStartLocations, chordDataObject) {
                if(chordStartLocations.length != chordDataObject.length){
                    chordStartLocations.pop()
                } else { // is new data
                    chordStartLocations.splice(0,0,'')
                    chordStartLocations.pop()
                }
                while(chordDataObject.length > chordStartLocations.length){
                    chordStartLocations.push(lyricRange.max[0])
                }
                var options = {}
                options.range = lyricRange;
                options.pips= {
                    mode: 'range',
                    format: {
                        to: function(a) {
                            return pipFormats[a];
                        }
                    }
                }
                if (chordDataObject.length){
                    options.tooltips = chordDataObject;
                    options.start= chordStartLocations;
                    options.tooltips= chordDataObject;
                } else {
                    // no chords on this song
                    options.start= [lyricRange.max[0]];
                }
                //  Make the slider
                var slider = self.$(`.slider-${tag}`)[0];  
                noUiSlider.create(slider, options);
                // noUiSlider.create(slider, {
                //     start: chordStartLocations,
                //     tooltips: chordDataObject,
                //     range: lyricRange,
                //     pips: {
                //         mode: 'range',
                //         format: {
                //             to: function(a) {
                //                 return pipFormats[a];
                //             }
                //         }
                //     }
                // });
            },
            // Params: Array, 0
            diacriticChecker: function(array, index) {
                var nextIndex = index + 1
                if (nextIndex >= array.length) {
                    return array;
                }
                //if ([' ྱ', ' ེ', ' ོ', ].includes(array[nextIndex])){
                if ([4017, 3962, 3964, 3954].includes((array[nextIndex]).charCodeAt(0))) {
                    array[index] = array[index].concat(array.splice(nextIndex, 1)[0]);
                } else { // only increase if no diacritic
                    ++index;
                }
                return self.diacriticChecker(array, index);
            },
            lineEditPopup: function(tag) {
                // app.panel.create(parameters)
                // closeByBackdropClick
                // el	:HTMLElementstring

                // app.panel.open(panel, animate)
                // Other option. pass app.js the line data to pre-generate this generated popup when a button it programatically generates is pressed. 
                // onclick, it calls one of these to update. 
                // That's also the way to change lang on song edit
                
                var langLine = ""
                line.phrases.forEach(phrase => {
                    if (phrase[tag]) {
                        langLine += phrase[tag];
                    }
                });
  
                var el = `<div class="popup">
                        <div class="block">
                            <strong><h3>*edit line text here</h3></strong>
                            <div class='tag'>${tag}</div>
                            <form class="item-content item-input line-form" id="line-form">
                                <div class="item-inner">
                                    <div class="item-input-wrap" id="item-input-wrap">
                                    <input type="text" class="lineText" style=''value="${langLine}"/>
                                    <span class="input-clear-button"></span>
                                    </div>
                                </div>
                            </form>
                            <p><a  href="#" class="col popup-close button button-fill">*Save</a></p>
                        </div>
                    </div>`
                var a = app.popup.create({
                    content:el,
                    'tag': tag,  
                    closeByBackdropClick: true,
                    on: {
                        opened: function (popup) {
                        console.log('Panel opened')
                        },
                        opened: function (popup) {
                            console.log('Popup opened');
                        },
                        close: function (popup) {
                            var tag = self.$$(".tag")[0].innerHTML
                            var formData = self.$$(".lineText")[0].value
                            self.updateLine(formData, tag)
                        },
                    }
                }); 
                a.open();
            },
            updateLine: function(data,tag){
                if (self.validateTag(tag)){
                    //update line and refresh
                    var lineArr = self.diacriticChecker(data.split(""), 0)
                    var chordPlacment = chordStartLocations[tag]

                    let i = 0
                    while (i < line.phrases.length) {
                        let firstChord = chordPlacment[i];
                        let startPhraseIndex = ((firstChord && firstChord < lineArr.length-1) ? firstChord : '0');
                        let nextChord = chordPlacment[i+1];
                        // checking that...
                        // the array may be shorter than we expect, allow phrases to be at end of array
                        // at end of array, include any extra characters
                        let endPhraseIndex = ((nextChord && nextChord < lineArr.length-1 && i < line.phrases.length) ? nextChord : (lineArr.length));

                        let phraseLength = endPhraseIndex - startPhraseIndex;
                        let newPhrase = lineArr.splice(0,phraseLength).join('');

                        //set it
                        line.phrases[i][tag] = newPhrase;
                        song.lyrics.verses[verseId].lines[lineId].phrases[i++][tag] = newPhrase;
                    }
                    self.clearSliders();
                    self.$setState({
                        loading: false,
                        song: song,
                        line: line
                    }, () => {
                        self.displayLyricSliders()
                        // User will need to save....
                    });                   
                }
            },
            validateTag: function(tag){
                if (languages.includes(tag)){
                    return true;
                }
                console.error("This should never fail")
                return false
            },
            backChecker: function(e){
                let newStatus = app.form.convertToData('#edit-donation')
                // Dirty is True if they don't match
                return (JSON.stringify(saveStatus) != JSON.stringify(newStatus))
                ev.preventDefault();
                // If status means form can be edited AND If form is dirty
                // then ask for confirmation 
                // complete 1581051573142 Submitted 1581051573215
                if (isDirty()) {
                    // 
                    var dialog = app.dialog.create({
                        backdrop: true,
                        closeByBackdropClick: false,
                        title: "<t>Leave this page?</t>",
                        text: "<t>Do you want to save your changes?</t>",
                        buttons: [{
                                text: "<t>Don't Save</t>",
                                onClick: (dialog, ev) => {
                                    this.$router.back();
                                }
                            },
                            {
                                text: "<t>Save</t>",
                                onClick: (dialog, ev) => {
                                    app.dialog.close()
                                    setStatus()
                                }
                            }
                        ],
                        verticalButtons: true
                    });
                    dialog.open();
                }
                // If form is empty, go back immediately
                else {
                    this.$router.back();
                }
            }
        }
    }
</script>